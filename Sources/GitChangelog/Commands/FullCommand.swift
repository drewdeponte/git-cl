import Foundation
import ArgumentParser

struct FullCommand: ParsableCommand {
    enum CodingKeys: String, CodingKey {
        case pre = "pre"
    }

    private let git: GitShell
    private let changelogCommits: ChangelogCommits

    static var configuration: CommandConfiguration {
        return .init(
            commandName: "full",
            abstract: "All Unreleased and Released Changes",
            discussion: "Returns all of the unreleased and released in changelog"
        )
    }

    @Flag(name: .shortAndLong, help: "Include pre-releases in the output")
    var pre: Bool
    
    init() {
        self.git = try! GitShell(bash: Bash())
        self.changelogCommits = try! ChangelogCommits(commits: self.git.commits())
    }
    
    init(from decoder: Decoder) throws {
        self.git = try! GitShell(bash: Bash())
        self.changelogCommits = try! ChangelogCommits(commits: self.git.commits())

        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.pre = try container.decode(Bool.self, forKey: .pre)
    }
    
    func run() throws {
        var versionShas: [(String, String, String)] = []

        let releases = try self.git.tags()
            .compactMap({ Release($0) })
            .filter({ self.pre ? true : !$0.isPreRelease })
            .sorted(by: >) // sort in decending order

        print("""
        # Changelog

        All notable changes to this project will be documented in this file.

        The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).

        Generated by [Git Changelog](https://github.com/uptech/git-cl), an open source project brought to you by [UpTech Works, LLC](https://upte.ch). A consultancy that partners with companies to help **build**, **launch**, and **refine** their products.

        """)

        // print unreleased
        let checkedOutBranch = try! self.git.getCheckedOutBranch()
        if let unreleasedDetails = ReleaseDetails(for: checkedOutBranch, using: self.git, startsOnRelease: false, includePreReleases: self.pre) {
            versionShas.append(("Unreleased", unreleasedDetails.startingSha1, unreleasedDetails.endingSha1))
            print(markdownUnreleased(unreleasedDetails.changelogEntries, withLinkRef: true))
        } else {
            print(markdownUnreleased([:]))
        }

        // print releases
        for release in releases {
            let details = ReleaseDetails(for: release.tag, using: self.git, includePreReleases: self.pre)!
            versionShas.append((details.tag, details.startingSha1, details.endingSha1))
            print(markdownRelease(releaseID: details.tag, date: details.date, categorizedEntries: details.changelogEntries, withLinkRef: true))
        }

        // print the link references
        if let repositoryURL = self.repositoryURL() {
            versionShas.forEach { versionShaInfo in
                if let diffURL = compareURL(repositoryURL, fromSha: String(versionShaInfo.2.prefix(7)), toSha: String(versionShaInfo.1.prefix(7))) {
                    print("[\(versionShaInfo.0)]: \(diffURL.absoluteString)")
                }
            }
        }
    }

    private func repositoryURL() -> URL? {
        if let urlString = try? self.git.findRespoitoryOriginURL()?.absoluteString {
            return URL(string: urlString)
        } else {
            return nil
        }
    }
}
